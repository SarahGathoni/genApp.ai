"use strict";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.processCountTokenResponse = exports.processNonStream = exports.getResponseStream = exports.processStream = exports.throwErrorIfNotOK = void 0;
const errors_1 = require("../types/errors");
async function throwErrorIfNotOK(response) {
    if (response === undefined) {
        throw new errors_1.GoogleGenerativeAIError('response is undefined');
    }
    if (!response.ok) {
        const status = response.status;
        const statusText = response.statusText;
        const errorBody = await response.json();
        const errorMessage = `got status: ${status} ${statusText}. ${JSON.stringify(errorBody)}`;
        if (status >= 400 && status < 500) {
            throw new errors_1.ClientError(errorMessage);
        }
        throw new errors_1.GoogleGenerativeAIError(errorMessage);
    }
}
exports.throwErrorIfNotOK = throwErrorIfNotOK;
const responseLineRE = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
async function* generateResponseSequence(stream) {
    const reader = stream.getReader();
    while (true) {
        const { value, done } = await reader.read();
        if (done) {
            break;
        }
        yield value;
    }
}
/**
 * Process a response.body stream from the backend and return an
 * iterator that provides one complete GenerateContentResponse at a time
 * and a promise that resolves with a single aggregated
 * GenerateContentResponse.
 *
 * @param response - Response from a fetch call
 * @ignore
 */
async function processStream(response) {
    if (response === undefined) {
        throw new Error('Error processing stream because response === undefined');
    }
    if (!response.body) {
        throw new Error('Error processing stream because response.body not found');
    }
    const inputStream = response.body.pipeThrough(new TextDecoderStream('utf8', { fatal: true }));
    const responseStream = getResponseStream(inputStream);
    const [stream1, stream2] = responseStream.tee();
    return Promise.resolve({
        stream: generateResponseSequence(stream1),
        response: getResponsePromise(stream2),
    });
}
exports.processStream = processStream;
async function getResponsePromise(stream) {
    const allResponses = [];
    const reader = stream.getReader();
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
            return aggregateResponses(allResponses);
        }
        allResponses.push(value);
    }
}
/**
 * Reads a raw stream from the fetch response and join incomplete
 * chunks, returning a new stream that provides a single complete
 * GenerateContentResponse in each iteration.
 * @ignore
 */
function getResponseStream(inputStream) {
    const reader = inputStream.getReader();
    const stream = new ReadableStream({
        start(controller) {
            let currentText = '';
            return pump();
            function pump() {
                return reader.read().then(({ value, done }) => {
                    if (done) {
                        if (currentText.trim()) {
                            controller.error(new Error('Failed to parse stream'));
                            return;
                        }
                        controller.close();
                        return;
                    }
                    currentText += value;
                    let match = currentText.match(responseLineRE);
                    let parsedResponse;
                    while (match) {
                        try {
                            parsedResponse = JSON.parse(match[1]);
                        }
                        catch (e) {
                            controller.error(new Error(`Error parsing JSON response: "${match[1]}"`));
                            return;
                        }
                        controller.enqueue(parsedResponse);
                        currentText = currentText.substring(match[0].length);
                        match = currentText.match(responseLineRE);
                    }
                    return pump();
                });
            }
        },
    });
    return stream;
}
exports.getResponseStream = getResponseStream;
/**
 * Aggregates an array of `GenerateContentResponse`s into a single
 * GenerateContentResponse.
 * @ignore
 */
function aggregateResponses(responses) {
    var _a, _b;
    const lastResponse = responses[responses.length - 1];
    if (lastResponse === undefined) {
        throw new Error('Error processing stream because the response is undefined');
    }
    const aggregatedResponse = {
        candidates: [],
        promptFeedback: lastResponse.promptFeedback,
    };
    for (const response of responses) {
        for (let i = 0; i < response.candidates.length; i++) {
            if (!aggregatedResponse.candidates[i]) {
                aggregatedResponse.candidates[i] = {
                    index: response.candidates[i].index,
                    content: {
                        role: response.candidates[i].content.role,
                        parts: [{ text: '' }],
                    },
                };
            }
            if (response.candidates[i].citationMetadata) {
                if (!((_a = aggregatedResponse.candidates[i].citationMetadata) === null || _a === void 0 ? void 0 : _a.citationSources)) {
                    aggregatedResponse.candidates[i].citationMetadata = {
                        citationSources: [],
                    };
                }
                const existingMetadata = (_b = response.candidates[i].citationMetadata) !== null && _b !== void 0 ? _b : {};
                if (aggregatedResponse.candidates[i].citationMetadata) {
                    aggregatedResponse.candidates[i].citationMetadata.citationSources =
                        aggregatedResponse.candidates[i].citationMetadata.citationSources.concat(existingMetadata);
                }
            }
            aggregatedResponse.candidates[i].finishReason =
                response.candidates[i].finishReason;
            aggregatedResponse.candidates[i].finishMessage =
                response.candidates[i].finishMessage;
            aggregatedResponse.candidates[i].safetyRatings =
                response.candidates[i].safetyRatings;
            if ('parts' in response.candidates[i].content) {
                for (const part of response.candidates[i].content.parts) {
                    if (part.text) {
                        aggregatedResponse.candidates[i].content.parts[0].text += part.text;
                    }
                    if (part.functionCall) {
                        aggregatedResponse.candidates[i].content.parts[0].functionCall =
                            part.functionCall;
                        // the empty 'text' key should be removed if functionCall is in the
                        // response
                        delete aggregatedResponse.candidates[i].content.parts[0].text;
                    }
                }
            }
        }
    }
    aggregatedResponse.promptFeedback =
        responses[responses.length - 1].promptFeedback;
    return aggregatedResponse;
}
/**
 * Process model responses from generateContent
 * @ignore
 */
async function processNonStream(response) {
    if (response !== undefined) {
        // ts-ignore
        const responseJson = await response.json();
        return Promise.resolve({
            response: responseJson,
        });
    }
    return Promise.resolve({
        response: { candidates: [] },
    });
}
exports.processNonStream = processNonStream;
/**
 * Process model responses from countTokens
 * @ignore
 */
async function processCountTokenResponse(response) {
    // ts-ignore
    return response.json();
}
exports.processCountTokenResponse = processCountTokenResponse;
//# sourceMappingURL=post_fetch_processing.js.map