"use strict";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatSessionPreview = exports.ChatSession = void 0;
const generate_content_1 = require("../functions/generate_content");
const errors_1 = require("../types/errors");
const util_1 = require("../util");
/**
 * Chat session to make multi-turn send message request.
 * Users can instantiate this using startChat method in GenerativeModel class.
 * `sendMessage` method makes async call to get response of a chat message.
 * `sendMessageStream` method makes async call to stream response of a chat message.
 */
class ChatSession {
    get history() {
        return this.historyInternal;
    }
    /**
     * @constructor
     * @param {StartChatSessionRequest} request - {@link StartChatSessionRequest}
     */
    constructor(request) {
        var _a;
        this._send_stream_promise = Promise.resolve();
        this.project = request.project;
        this.location = request.location;
        this.googleAuth = request.googleAuth;
        this.publisher_model_endpoint = request.publisher_model_endpoint;
        this.historyInternal = (_a = request.history) !== null && _a !== void 0 ? _a : [];
        this.generation_config = request.generation_config;
        this.safety_settings = request.safety_settings;
        this.tools = request.tools;
        this.api_endpoint = request.api_endpoint;
    }
    /**
     * Get access token from GoogleAuth. Throws GoogleAuthError when fails.
     * @return {Promise<any>} Promise of token
     */
    get token() {
        const tokenPromise = this.googleAuth.getAccessToken().catch(e => {
            throw new errors_1.GoogleAuthError(util_1.constants.CREDENTIAL_ERROR_MESSAGE, e);
        });
        return tokenPromise;
    }
    /**
     * Make an sync call to send message.
     * @param {string | Array<string | Part>} request - send message request. {@link Part}
     * @return {Promise<GenerateContentResult>} Promise of {@link GenerateContentResult}
     */
    async sendMessage(request) {
        const newContent = formulateNewContentFromSendMessageRequest(request);
        const generateContentrequest = {
            contents: this.historyInternal.concat(newContent),
            safety_settings: this.safety_settings,
            generation_config: this.generation_config,
            tools: this.tools,
        };
        const generateContentResult = await (0, generate_content_1.generateContent)(this.location, this.project, this.publisher_model_endpoint, this.token, generateContentrequest, this.api_endpoint, this.generation_config, this.safety_settings).catch(e => {
            throw e;
        });
        const generateContentResponse = await generateContentResult.response;
        // Only push the latest message to history if the response returned a result
        if (generateContentResponse.candidates.length !== 0) {
            this.historyInternal = this.historyInternal.concat(newContent);
            const contentFromAssistant = generateContentResponse.candidates[0].content;
            if (!contentFromAssistant.role) {
                contentFromAssistant.role = util_1.constants.MODEL_ROLE;
            }
            this.historyInternal.push(contentFromAssistant);
        }
        else {
            // TODO: handle promptFeedback in the response
            throw new Error('Did not get a candidate from the model');
        }
        return Promise.resolve(generateContentResult);
    }
    async appendHistory(streamGenerateContentResultPromise, newContent) {
        const streamGenerateContentResult = await streamGenerateContentResultPromise;
        const streamGenerateContentResponse = await streamGenerateContentResult.response;
        // Only push the latest message to history if the response returned a result
        if (streamGenerateContentResponse.candidates.length !== 0) {
            this.historyInternal = this.historyInternal.concat(newContent);
            const contentFromAssistant = streamGenerateContentResponse.candidates[0].content;
            if (!contentFromAssistant.role) {
                contentFromAssistant.role = util_1.constants.MODEL_ROLE;
            }
            this.historyInternal.push(contentFromAssistant);
        }
        else {
            // TODO: handle promptFeedback in the response
            throw new Error('Did not get a candidate from the model');
        }
    }
    /**
     * Make an async call to stream send message. Response will be returned in stream.
     * @param {string | Array<string | Part>} request - send message request. {@link Part}
     * @return {Promise<StreamGenerateContentResult>} Promise of {@link StreamGenerateContentResult}
     */
    async sendMessageStream(request) {
        const newContent = formulateNewContentFromSendMessageRequest(request);
        const generateContentrequest = {
            contents: this.historyInternal.concat(newContent),
            safety_settings: this.safety_settings,
            generation_config: this.generation_config,
            tools: this.tools,
        };
        const streamGenerateContentResultPromise = (0, generate_content_1.generateContentStream)(this.location, this.project, this.publisher_model_endpoint, this.token, generateContentrequest, this.api_endpoint, this.generation_config, this.safety_settings).catch(e => {
            throw e;
        });
        this._send_stream_promise = this.appendHistory(streamGenerateContentResultPromise, newContent).catch(e => {
            throw new errors_1.GoogleGenerativeAIError('exception appending chat history', e);
        });
        return streamGenerateContentResultPromise;
    }
}
exports.ChatSession = ChatSession;
/**
 * Chat session to make multi-turn send message request.
 * `sendMessage` method makes async call to get response of a chat message.
 * `sendMessageStream` method makes async call to stream response of a chat message.
 */
class ChatSessionPreview {
    get history() {
        return this.historyInternal;
    }
    /**
     * @constructor
     * @param {StartChatSessionRequest} request - {@link StartChatSessionRequest}
     */
    constructor(request) {
        var _a;
        this._send_stream_promise = Promise.resolve();
        this.project = request.project;
        this.location = request.location;
        this.googleAuth = request.googleAuth;
        this.publisher_model_endpoint = request.publisher_model_endpoint;
        this.historyInternal = (_a = request.history) !== null && _a !== void 0 ? _a : [];
        this.generation_config = request.generation_config;
        this.safety_settings = request.safety_settings;
        this.tools = request.tools;
        this.api_endpoint = request.api_endpoint;
    }
    /**
     * Get access token from GoogleAuth. Throws GoogleAuthError when fails.
     * @return {Promise<any>} Promise of token
     */
    get token() {
        const tokenPromise = this.googleAuth.getAccessToken().catch(e => {
            throw new errors_1.GoogleAuthError(util_1.constants.CREDENTIAL_ERROR_MESSAGE, e);
        });
        return tokenPromise;
    }
    /**
     * Make an sync call to send message.
     * @param {string | Array<string | Part>} request - send message request. {@link Part}
     * @return {Promise<GenerateContentResult>} Promise of {@link GenerateContentResult}
     */
    async sendMessage(request) {
        const newContent = formulateNewContentFromSendMessageRequest(request);
        const generateContentrequest = {
            contents: this.historyInternal.concat(newContent),
            safety_settings: this.safety_settings,
            generation_config: this.generation_config,
            tools: this.tools,
        };
        const generateContentResult = await (0, generate_content_1.generateContent)(this.location, this.project, this.publisher_model_endpoint, this.token, generateContentrequest, this.api_endpoint, this.generation_config, this.safety_settings).catch(e => {
            throw e;
        });
        const generateContentResponse = await generateContentResult.response;
        // Only push the latest message to history if the response returned a result
        if (generateContentResponse.candidates.length !== 0) {
            this.historyInternal = this.historyInternal.concat(newContent);
            const contentFromAssistant = generateContentResponse.candidates[0].content;
            if (!contentFromAssistant.role) {
                contentFromAssistant.role = util_1.constants.MODEL_ROLE;
            }
            this.historyInternal.push(contentFromAssistant);
        }
        else {
            // TODO: handle promptFeedback in the response
            throw new Error('Did not get a candidate from the model');
        }
        return Promise.resolve(generateContentResult);
    }
    async appendHistory(streamGenerateContentResultPromise, newContent) {
        const streamGenerateContentResult = await streamGenerateContentResultPromise;
        const streamGenerateContentResponse = await streamGenerateContentResult.response;
        // Only push the latest message to history if the response returned a result
        if (streamGenerateContentResponse.candidates.length !== 0) {
            this.historyInternal = this.historyInternal.concat(newContent);
            const contentFromAssistant = streamGenerateContentResponse.candidates[0].content;
            if (!contentFromAssistant.role) {
                contentFromAssistant.role = util_1.constants.MODEL_ROLE;
            }
            this.historyInternal.push(contentFromAssistant);
        }
        else {
            // TODO: handle promptFeedback in the response
            throw new Error('Did not get a candidate from the model');
        }
    }
    /**
     * Make an async call to stream send message. Response will be returned in stream.
     * @param {string | Array<string | Part>} request - send message request. {@link Part}
     * @return {Promise<StreamGenerateContentResult>} Promise of {@link StreamGenerateContentResult}
     */
    async sendMessageStream(request) {
        const newContent = formulateNewContentFromSendMessageRequest(request);
        const generateContentrequest = {
            contents: this.historyInternal.concat(newContent),
            safety_settings: this.safety_settings,
            generation_config: this.generation_config,
            tools: this.tools,
        };
        const streamGenerateContentResultPromise = (0, generate_content_1.generateContentStream)(this.location, this.project, this.publisher_model_endpoint, this.token, generateContentrequest, this.api_endpoint, this.generation_config, this.safety_settings).catch(e => {
            throw e;
        });
        this._send_stream_promise = this.appendHistory(streamGenerateContentResultPromise, newContent);
        return streamGenerateContentResultPromise;
    }
}
exports.ChatSessionPreview = ChatSessionPreview;
function formulateNewContentFromSendMessageRequest(request) {
    let newParts = [];
    if (typeof request === 'string') {
        newParts = [{ text: request }];
    }
    else if (Array.isArray(request)) {
        for (const item of request) {
            if (typeof item === 'string') {
                newParts.push({ text: item });
            }
            else {
                newParts.push(item);
            }
        }
    }
    return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
/**
 * When multiple Part types (i.e. FunctionResponsePart and TextPart) are
 * passed in a single Part array, we may need to assign different roles to each
 * part. Currently only FunctionResponsePart requires a role other than 'user'.
 * @ignore
 * @param {Array<Part>} parts Array of parts to pass to the model
 * @return {Content[]} Array of content items
 */
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
    const userContent = { role: util_1.constants.USER_ROLE, parts: [] };
    const functionContent = { role: util_1.constants.FUNCTION_ROLE, parts: [] };
    let hasUserContent = false;
    let hasFunctionContent = false;
    for (const part of parts) {
        if ('functionResponse' in part) {
            functionContent.parts.push(part);
            hasFunctionContent = true;
        }
        else {
            userContent.parts.push(part);
            hasUserContent = true;
        }
    }
    if (hasUserContent && hasFunctionContent) {
        throw new errors_1.ClientError('Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.');
    }
    if (!hasUserContent && !hasFunctionContent) {
        throw new errors_1.ClientError('No content is provided for sending chat message.');
    }
    if (hasUserContent) {
        return [userContent];
    }
    return [functionContent];
}
//# sourceMappingURL=chat_session.js.map